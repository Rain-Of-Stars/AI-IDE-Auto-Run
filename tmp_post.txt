        """窗口捕获主循环。"""
        self._logger.info("启动窗口捕获扫描循环")
        while self._running:
            t0 = time.monotonic()
            try:
                score = self._scan_window_and_maybe_click()
                # 显示实际后端（若配置为auto，则标注实际为窗口级）
                if getattr(self.cfg, 'capture_backend', 'screen') == 'auto':
                    backend_desc = "自动尝试截取（窗口级）"
                else:
                    backend_desc = "窗口级截取"
                self.sig_status.emit(f"运行中 | 后端: {backend_desc} | 上次匹配: {score:.3f}")
            except Exception as e:
                self._logger.exception("窗口扫描异常: %s", e)
                self.sig_log.emit(f"窗口扫描异常: {e}")
                # 出错回退到屏幕捕获
                self._run_screen_loop()
                return
            dt = (time.monotonic() - t0) * 1000.0
            sleep_ms = max(0, int(self.cfg.interval_ms - dt))
            if sleep_ms > 0:
                time.sleep(sleep_ms / 1000.0)

    def _run_screen_loop(self) -> None:
        """屏幕捕获主循环（原有逻辑封装）。"""
        try:
            with mss.mss() as sct:
                while self._running:
                    t0 = time.monotonic()
                    try:
                        score = self._scan_once_and_maybe_click(sct)
                        # 后端描述：若配置为auto但实际走屏幕，则明确为“自动(屏幕)”
                        if getattr(self.cfg, 'capture_backend', 'screen') == 'auto':
                            backend_desc = "自动尝试截取（传统屏幕）"
                        else:
                            backend_desc = "传统屏幕区域截取"

                        if self.cfg.enable_multi_screen_polling:
                            status_msg = f"运行中 | 后端: {backend_desc} | 多屏轮询 | 当前屏幕: {self._current_polling_monitor} | 匹配: {score:.3f}"
                        else:
                            status_msg = f"运行中 | 后端: {backend_desc} | 上次匹配: {score:.3f}"
                        self.sig_status.emit(status_msg)
                    except Exception as e:
                        self._logger.exception("屏幕扫描异常: %s", e)
                        self.sig_log.emit(f"屏幕扫描异常: {e}")
                    dt = (time.monotonic() - t0) * 1000.0
                    sleep_ms = max(0, int(self.cfg.interval_ms - dt))
                    if sleep_ms > 0:
                        time.sleep(sleep_ms / 1000.0)
        except Exception as e:
            self._logger.exception("mss 初始化失败: %s", e)
            self.sig_log.emit(f"mss 初始化失败: {e}")
            self.sig_status.emit("已停止")

    def _apply_roi_to_image(self, img: np.ndarray) -> Tuple[np.ndarray, int, int]:
        """将配置的ROI应用到窗口图像上，返回(裁剪图, roi_left, roi_top)。"""
        roi: ROI = self.cfg.roi
        h, w = img.shape[:2]
        if roi.w > 0 and roi.h > 0:
            x = max(0, min(int(roi.x), w - 1))
            y = max(0, min(int(roi.y), h - 1))
            rw = max(1, min(int(roi.w), w - x))
            rh = max(1, min(int(roi.h), h - y))
            return img[y:y+rh, x:x+rw].copy(), x, y
        return img, 0, 0

    def _get_window_rect(self, hwnd: int) -> Tuple[int, int, int, int]:
        """读取窗口矩形（屏幕坐标）。"""
        rect = wintypes.RECT()
        if ctypes.WinDLL('user32', use_last_error=True).GetWindowRect(hwnd, ctypes.byref(rect)):
            return rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top
        return 0, 0, 0, 0

    def _scan_window_and_maybe_click(self) -> float:
        """窗口捕获一次并可能点击。"""
        # 模板就绪检查
        if not self._templates:
            self._load_templates(force=True)
            if not self._templates:
                self.sig_status.emit("模板未就绪")
                time.sleep(0.5)
                return 0.0

        if not self._window_capture_manager:
            # 无管理器则直接回退
            return 0.0

        img = self._window_capture_manager.capture_frame(
            restore_after_capture=getattr(self.cfg, 'restore_minimized_after_capture', False)
        )
        if img is None:
            # 允许在auto模式回退到屏幕捕获
            if getattr(self.cfg, 'capture_backend', 'screen') == 'auto':
                self._run_screen_loop()
            return 0.0

        if self.cfg.save_debug_images:
            self._save_debug_image(img, "window_capture")

        roi_img, roi_l, roi_t = self._apply_roi_to_image(img)
        if self.cfg.grayscale and roi_img.ndim == 3:
            roi_img = cv2.cvtColor(roi_img, cv2.COLOR_BGR2GRAY)

        score, loc, wh = self._match_best(roi_img)
        threshold = max(0.0, min(1.0, float(self.cfg.threshold)))
        if self.cfg.debug_mode and score > 0.1:
            self._logger.info(f"窗口匹配: score={score:.3f}, threshold={threshold:.3f}, loc={loc}, size={wh}")

        if score >= threshold:
            self._consecutive += 1
        else:
            self._consecutive = 0

        now = time.monotonic()
        if self._consecutive >= max(1, self.cfg.min_detections) and now >= self._next_allowed:
            x, y = loc
            w, h = wh
            # 窗口内坐标
            wx = roi_l + x + w // 2 + int(self.cfg.click_offset[0])
            wy = roi_t + y + h // 2 + int(self.cfg.click_offset[1])
